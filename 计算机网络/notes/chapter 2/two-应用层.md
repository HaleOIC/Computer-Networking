# two-应用层

应用层是协议最多的层次，它包括各种各样的网络应用，并且我们需要知道的是：

​	**网络核心中没有应用层应用**，也就是说，**所有的应用层应用都是在端系统中实现的**。

而当下网络应用纷繁复杂，例如$E-mail$, $Web$, $Internet电话$，$Youtube, Netfilx$

## 2.1 应用层协议原理

### 2.1.1 网络应用程序体系结构

主流的应用架构有：

- 客户-服务器模式$(C/S:client/server)$
- 对等模式$(P2P:Peer To  Peer)$
- 混合体：客户-服务器和对等体系结构

#### 客户-服务器模式

服务器：

- 一直运行
- 固定的$IP$地址和周至的端口号（约定）
- 扩展性：服务器场
  - 数据中心进行扩展
  - 扩展性差

客户端：

- 主动与服务器通信
- 与互联网有间隙性的连接
- 可能是动态$IP$地址
- 不直接与其他客户端通信

#### 对等体($P2P$)体系结构

- 几乎没有一直运行的服务器
- 任意端系统之间可以通信
- 每一个节点可以是客户端也可以是服务器（主要是按照服务情况划分）
  - 自扩展性：新的$peer$节点带来新的服务能力，当然也带来新的服务请求
- 参与的主机间歇性连接可以改变$IP$地址 ，**从而使得其难以管理**

#### 混合体体系结构

##### Napster

- 文件搜索：集中式
  - 主机在中心服务器上注册其资源
  - 主机向中心服务器查询资源位置
- 文件传输：$P2P$
  - 任意$Peer$节点之间

##### 即时通信

- 在线检测：集中
  - 当用户上线时，向中心服务器注册其$IP$地址
  - 当用户和中心服务器联系，以找到其在线好友的位置
- 两个用户之间聊天：$P2P$

### 2.1.2 进程通信

用操作系统的术语来说，进行通信的实际上是 **进程($process$)** 而不是程序。

在两个不同端系统上的进程，通过跨越计算机网络交换**报文($Message$)**而相互通信。

**客户端进程**：发起通信的进程；**服务器进程**：等待连接的进程

分布式进程通信需要解决的三个问题：

- 进程标示和寻址问题（服务用户） 
- 传输层-应用层提供服务是如何（服务） 
- 如何使用传输层提供的服务，实现应用进 程之间的报文交换，实现应用（用户使用服务） 

#### 问题1：对进程进行编址 ($address$)

- 进程为了接收报文，必须有一个标识 即：$SAP$（发送也需要标示） 
  - 主机：唯一的32位$IP$地址
    - 仅仅有IP地址不能够唯一标示一个进程；在一台端系统上有很 多应用进程在运行。
  - 所采用的传输层协议：$TCP$  $or$  $UDP $
  - 端口号 ($Port Numbers$)
- 从而有一个进程：用 $IP + Port$标示 **端节点**
- 本质上，一对主机进程之间的通信由2个端节点构成

#### 问题2：传输层提供的服务-需要穿过层间的信息

-  层间接口必须要携带的信息
  - 要传输的报文（对本层来说：$SDU$）
  - 谁传的：对方的应用进程的标识 $IP+TCP(UDP)$端口
  - 传给谁：对方的应用进程的标示：对方的$IP+TCP(UDP)$端口号 
- 传输层实体（$TCP$或者$UDP$实体）根据这些信息进行$TCP$ 报文段（$UDP$数据报）的封装 
  - 源端口号，目标端口号，数据等 
  - 将IP地址往下交IP实体，用于封装$IP$数据报：源$IP$,目标$IP$

#### 问题2(续)：传输层提供的服务-层间信息的代表

- 如果$Socket API$每次传输报文，都携带如此多的信息，不容易管理
- 用个代号（一般是个整数）标示通信的双方或单方：$Socket$

#### 问题3：如何使用传输层提供的服务实现应用 

- 定义应用层协议：报文格式，解释，时序等
- 编制程序，通过API调用网络基础设施提供通信服务传报文，解析报文，实现应用时序等

#### $TCP$  $Socket$

  - $tcp$服务，两个进程之间的通信需要之前要建立连接
    - 两个进程通信会持续一段时间，通信关系稳定
  - 可以用一个整数表示两个应用实体之间的通信关系 ，**本地标示** 
  - 穿过层间接口的信息量**最小** 
  - $TCP$ $socket$：(源IP,源端口,目标IP,目标端口 ) 四元组



![](img/2-1-1.png)

#### $UDP$ $Socket$

- $UDP$ 服务，两个进程之间的通信需要之前无需建立连接
  - 每个报文都是独立传输的
  - 前后报文可能给不同的分布式进程
- 因此只能用一个整数表示本应用实体的标示
- 穿过层间接口的信息大小**最小**
- $UDP$ $Socket$ ： 本$IP$，本端口
- 到那时传输报文的时候，必须提供对方的$IP$，$Port$
  - 接收报文的时候，传输层需要上传对方的$IP$,$Port$

![1659060353258](img/2-1-2.png)

### 2.1.3 可供应用使用的运输服务

描述传输层服务的指标：

- 数据丢失率
  - 有些应用则要求100%的可 靠数据传输（如文件） 
  - 有些应用（如音频）能容忍 一定比例以下的数据丢失 
- 延迟
  - 一些应用由于出于有效性考虑，对于数据传输由严格的时间限制
- 吞吐
  - 一些应用（如多媒体）必须 需要最小限度的吞吐，从而 使得应用能够有效运转 
  - 一些应用能充分利用可供使 用的吞吐(弹性应用）
- 安全性
  - 机密性
  - 完整性
  - 可认证性（鉴别）



### 2.1.4 $Internet$传输层提供的服务

#### $Tcp$提供的服务

- 可靠的传输服务
- 流量控制：发送方不会淹没接收方
- 拥塞控制：当网络出现拥塞时，能抑制发送方
- 不能提供的服务：时间保证、最小吞吐保证和安全
- 面向对象连接：要求在客户端 进程和服务器进程之间建立连接 

#### $UDP$服务：

- 不可靠数据传输 
- 不提供的服务：可靠， 流量控制、拥塞控制、 时间、带宽保证、建立 连接 

#### $UDP$存在的必要性

- 能够区分不同的进程，而IP服务不能 
  - 在IP提供的主机到主机端到端功能的基础上，区分了主机的 应用进程 
- **无需建立连接**，省去了建立连接时间，适合事务性的 应用 
- **不做可靠性的工作**，例如检错重发，适合那些对实时 性要求比较高而对正确性要求不高的应用 
  - 因为为了实现可靠性（准确性、保序等），必须付出时间代 价（检错重发） 
- 没有拥塞控制和流量控制，**应用能够按照设定的速度 发送数据** 
  - 而在TCP上面的应用，应用发送数据的速度和主机向网络发送 的实际速度是不一致的，因为有流量控制和拥塞控制 

#### 安全$TCP$

##### $TCP$ & $UDP$

- 都没有加密
- 明文通过互联网传输，甚至密码

##### $SSL$

- 在TCP上面实现，提供加密的 $TCP$ 连接 
- 私密性
- 数据完整性
- 端到端的鉴别

### 2.1.5 应用层协议

- 定义了：运行在不同端系统上 的应用**进程**如何相互交换报文 
  - 交换的 **报文类型**：请求和应答报文
  - 各种报文类型的 **语法**：报文中的各个字段及其描述
  - 字段的 **语义**： 即字段取值的含义
  - 进程何时、如何发送报文及对报文进行相应的 **规则**
- 应用协议仅仅是应用的一个组成部分

协议同样分成公开协议和私有协议

- 公开协议：
  - 由$RFC$文档定义
  - 允许互操作
  - 如$HTTP$ ，$SMAP$
- 专用协议：
  - 协议不公开
  - 如：$Skype$



